# wrapperservice服务说明
wrapperservice服务把整个ps的子服务功能进行了包装. 主要的流程分为一下几个部分.

- step1: 对召回的商品做截断
```c++
input(输入数据): 
    maxItemLimit
    context->reqPb.get()
    itemIds: std::vector<long> itemIds
process(处理过程):
    overallTruncate/perRecallTruncate/dividEquallyTruncateLowHostsale
update(更新数据):
    itemIds
```

- step2: 取商品属性数据
```c++
请求的数据格式
struct ItemProfileReq {
    ItemType type;
    std::vector<int64_t> itemIds;
    std::string location;
    ItemProfileFlags::FlagSet flagSet;
    std::shared_ptr<ReqPb> reqPb;

    ItemProfileReq(ItemType t, std::vector<int64_t>&& items,
        std::string location, ItemProfileFlags::FlagSet flagSet, std::shared_ptr<ReqPb> reqPb):
        type(t), itemIds(items), location(location), flagSet(flagSet), reqPb(reqPb) {}
};


input:
    context->itemProfileReqPtr = std::make_shared<ItemProfileReq>(ItemType::SKU, std::move(itemIds),context->reqPb->location(), flagSetFeature|flagSetFilter, context->reqPb);
    std::shared_ptr<folly::Promise<ItemPropertiesPtr>> itemPropertiesPromisePtr = std::make_shared<folly::Promise<ItemPropertiesPtr>>();
process:
    itemProfileService->acceptRequest(*context->itemProfileReqPtr, context->itemPropertiesPromisePtr, nullptr)
update:
    itemPropertiesPromisePtr
```

- step3: 过滤
```c++
input:
    context->itemPropertiesPtr = t.value();
    PredictionService::filter::FilterParam filterParam(context->filterParam, context->reqPb);
process:
    filter_->DoFilter(filterParam, context->itemPropertiesPtr);  // 根据一系列的条件进行过滤, 指针位置更新.
update:
    itemPropertiesPtr
```

- step4: 计算特征
```c++
请求的数据格式
struct FeatureGenReq {
    std::shared_ptr<ReqPb> psReq;
    // typedef std::vector<std::shared_ptr<ItemProperty> > ItemProperties;
    std::shared_ptr<ItemProperties> itemProps;  // 商品属性的列表
    std::shared_ptr<PredictorKVWVectorType> cid3RelativeMap;
    const Bucket* bucketPtr;
};

input:
    context->featureGenReqPtr = std::make_shared<FeatureGenReq>();
    context->featureGenReqPtr->itemProps = context->itemPropertiesPtr;
    context->featureGenReqPtr->psReq = context->reqPb;
    context->featureGenReqPtr->bucketPtr = context->bucketPtr;
    context->featureGenReqPtr->cid3RelativeMap = context->cid3RelativeMap;

    std::shared_ptr<folly::Promise<ItemFeatureVecPtr>> itemFeatureVecPromisePtr = std::make_shared<folly::Promise<ItemFeatureVecPtr>>();
process:
    featureGenerationService->acceptRequest(*context->featureGenReqPtr, context->itemFeatureVecPromisePtr, dbgInfo);
update:
    itemFeatureVecPromisePtr
```

- step5: 打分
```c++
input:
    context->itemFeatureVecPtr = t.value();
    context->evaluationReqPtr = std::make_shared<EvaluationReq>();
    context->evaluationReqPtr->bucketPtr = context->bucketPtr;
    context->evaluationReqPtr->itemFeatures = context->itemFeatureVecPtr;

    std::shared_ptr<folly::Promise<ItemScoreListPtr>> itemScoreListPromisePtr = std::make_shared<folly::Promise<ItemScoreListPtr>>();
process:
    evaluationService->acceptRequest(*context->evaluationReqPtr, context->itemScoreListPromisePtr, nullptr);
update:
    itemScoreListPromisePtr
```

- step6: feature log服务
```c++
请求的数据格式
typedef struct {
    std::string key; // log key generated by request server ip, pin and request server timestamp
    // the value must be in consistent with the one recorded by request instrumentation
    std::string uuid; // device id or browser unique id
    std::string topic; // topic of feature log
    std::string recId; // recommendation id
    std::string logContent; // feature log content
} FeatureLogReq;

input:
    FeatureLogReq featureLogReq;
    featureLogReq.key = featureLogKey;
    featureLogReq.recId = "rec." + placementId;
    featureLogReq.topic = placementId;
    featureLogReq.uuid = uuid;
    featureLogReq.logContent = ss.str();

    std::shared_ptr<folly::Promise<int>> featureLogPromise = std::make_shared<folly::Promise<int>>();
process:
    featureLogService->acceptRequest(featureLogReq, featureLogPromise, nullptr);
update:
    featureLogPromise
```

- step7: 生成服务的最终返回 context->res
```c++
auto respPb = std::make_shared<recsys::prediction_service::PredictionServiceResponse>();
context->res->setValue(PsHttpResponse(pb2json(*respPb)))
or
context->res->setValue(PsHttpResponse(respPb->SerializeAsString()));
```
